Многие ошибки, связанные с синхронизацией и разделением общих областей памяти исключены при работе с асинхронным кодом, потому что асинхронный цикл выполняется в одном потоке (соответственно, нет проблем многопоточных приложений). 

Исключено большинство ошибок, но не все. Например, если написать кастомную функцию инкремента и добавить в нее ошибку, то инкрементация никогда не будет происходить. Это очень простой пример, но он полностью передает суть возможных ошибок. Здесь нарушена атомарность операции инкремента (с помощью `await asyncio.sleep(0.01`). 

Ошибки конкурентности возможны в том случае, если неправильно определена логика приложения. В примере ошибка происходит в точке ожидания `await`. Такие ошибки повсеместны, так как именно в этой точке передается управление - тогда получается, что на состояние данных можно повлиять извне с помощью другой сопрограммы, функции или объекта. 

```
import asyncio

counter: int = 0


async def increment():
    global counter
    temp_counter = counter
    temp_counter = temp_counter + 1
    await asyncio.sleep(0.01)
    counter = temp_counter


async def main():
    global counter
    for _ in range(1000):
        tasks = [asyncio.create_task(increment()) for _ in range(100)]
    await asyncio.gather(*tasks)
    print(f"Счетчик равен {counter}")
    assert counter == 100
    counter = 0


asyncio.run(main())

```

___
Relations: [[asyncio Python]] 
Tags: #theory #practice 
References: [[Asyncio (книга)]] 
Query: 