При анализе алгоритмов особое внимание стоит уделить входным данным. Если рассматривать пример алгоритма, который ищет наибольшее число в массиве, то от входного набора данных будет зависеть скорость работы алгоритма. 
1. Если массив отсортирован по убыванию, то мы изначально будем иметь наибольший элемент массива и во всех последующих проверках не будем делать присваивания значения, т.к. уже имеем наибольший элемент. 
2. Если массив отсортирован по возрастанию, то наоборот, мы сделаем N операций присваивания, так как каждое последующее число будет больше текущего значения. 

Невозможно рассмотреть множество всех возможных значений входных данных алгоритма: например, для массива из 10 чисел множество перестановок  $=10!=3628800$ случаев. Проблема в том, что входной набор данных может оказаться тем, что показывает наименьшее время работы в рамках заданного алгоритма. 

Для более подробного анализа алгоритма используются ***классы входных данных***. Например, для массива из 10 элементов можно определить $N$ классов в зависимости от того, что делает алгоритм. Для описанного ниже алгоритма можно определить 10 классов: каждый из них будет представлять набор входных данных, где наибольшее число находится на позиции с индексом от $0$ до $N-1$.  

Оценка скорости работы алгоритма проводится на следующих подмножествах множества определенных классов входных данных:
1. ***Наилучший случай***. Это тот набор данных из всего множества, на котором алгоритм отрабатывает за наименьшее время, относительно прочих наборов из того же множества. Например, для алгоритма поиска это тот случай, когда искомое значение записано в первой проверяемой ячейке - в таком случае, алгоритму потребуется всего лишь одно сравнение (вне зависимости от его сложности). 
2. ***Наихудший случай***. Анализ наихудшего случая важен, так как именно это случай описывает максимальное время выполнения алгоритма. Соответственно, входной набор данных из множества классов входных данных должен быть таким, чтобы на нем время выполнения алгоритма было максимальным по сравнению с прочими наборами из множества. Например, для алгоритма поиска это тот случай, когда искомое значение записано в самой последней проверяемой ячейке. 
3. ***Средний случай***. 
	1. На первом этапе определяются различные группы, на которые следует разбить возможные входные наборы данных. 
	2. На втором этапе определяется вероятность, с которой входной набор данных будет принадлежать одной из определенных групп. 
	3. На третьем этапе для каждой группы подсчитывается время выполнения алгоритма. Время выполнения алгоритма на каждом наборе данных в рамках одной группы должно быть одинаковым, в противном случае группы необходимо разбить на частные случаи. 
	4. Высчитывается среднее время работы алгоритма $A(n)=\sum\limits_{i=1}^{m} p_i t_i$ где через $n$ обозначен размер входных данных, $m$ - число групп, $p_i, t_i$ - вероятность принадлежности входных данных какой-либо группе и время работы алгоритма для этой группы сооветственно. 

___
```
#python
list: list[int]

largest = list[0]
for i in range(1, len(largest)):
	if (list[i] > largest):
		largest = list[i]

```
___

Relations: [[Анализ алгоритмов]] 
Tags: #code
References: [[Основы современных алгоритмов Макконел]] 
Query: 