***Deadlock***. ***Взаимоблокировка***. Взаимоблокировкой называется ситуация, когда имеет место неразрешимая ситуация за разделяемый ресурс, в результате чего приложение зависает. 
![[Pasted image 20230916174649.png]]

В случае с несколькими потоками, реентабельная блокировка не поможет, так как ***потоки захватывают разные блокировки и взаимно требуют прочие захваченные***. Гипотетическая ситуация представлена в коде ниже. 

Решения взаимоблокировок:
1. Алгоритм страуса - игнорировать проблему, так как она обычно возникает очень редко и решать перезапуском программы, так как может появиться только в специфических условиях (когда не повезет). 
2. Захват блокировок в одном и том же порядке. В приведенном ниже коде это поможет - нужно лишь захватывать сначала `lock_a` и затем `lock_b` для обоих функций. 
3. Использовать одну блокировку заместо двух. Такой случай исключает взаимоблокировку. 

___
```
from threading import Lock, Thread
import time

lock_a = Lock()
lock_b = Lock()


def a():
    with lock_a:
        print("Захвачена блокировка a")
        time.sleep(1)
        with lock_b:
            print("Захвачены обе блокировки из метода a")


def b():
    with lock_b:
        print("Захвачена блокировка b")
        with lock_a:
            print("Захвачены обе блокировки из метода b")


thread_1 = Thread(target=a)
thread_2 = Thread(target=b)
thread_1.start()
thread_2.start()
thread_1.join()
thread_2.join()

```
___

Relations: [[Блокировки, разделяемые данные и взаимоблокировки в пуле потоков]] [[Python Hints]] 
Tags: #code 
References: [[Asyncio (книга)]] 
Query: 