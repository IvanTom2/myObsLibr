Разделяемые области памяти всегда являются проблемными точками распараллеливания. Эти области кода называют критическими и им стоит уделять особое внимание - так как в них код нужно выполнять строго последовательно и исключать любую возможную конкурентность, чтобы не достичь состояния гонки. 

Критической областью кода можно назвать, например, какой-либо счетчик действий. Если несколько процессов будут обращаться и записывать в него значения одновременно, то обязательно случится такая ситуация, когда два или более процессов одновременно попытаются записать новое значение - в таком случае будет записано только одно значение (например, инкремент), хотя нам нужно, чтобы счетчик увеличился на три значения. 

Для избежания таких ситуаций применяются блокировки и прочие инструменты. Их смысл заключается в том, чтобы ограничить совместный доступ к данным, например, за счет выстраивания очереди обращений к области данных. 

В пуле процессов мы не управляем процессами вручную. Это осложняет управление критическими областями кода. Для разрешения данной проблемы используются ***инициализаторы пула процессов***. С помощью инициализатора мы можем создать ссылку на разделяемую область памяти во время создания пула процессов. 

___
```
from concurrent.futures import ProcessPoolExecutor
import asyncio
from multiprocessing import Value


shared_counter: Value


def init(counter: Value):
    global shared_counter
    shared_counter = counter


def increment():
    with shared_counter.get_lock():
        shared_counter.value += 1


async def main():
    counter = Value("d", 0)
    with ProcessPoolExecutor(
        4,
        initializer=init,
        initargs=(counter,),
    ) as process_pool:
        await asyncio.get_running_loop().run_in_executor(process_pool, increment)
        print(counter.value)


if __name__ == "__main__":
    asyncio.run(main())

```
___

Relations: [[Python Hints]] [[Пул процессов в цикле событий asyncio Python]]
Tags: #code
References: [[Asyncio (книга)]] 
Query: 