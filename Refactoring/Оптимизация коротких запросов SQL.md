___
При оптимизации короткого запроса известно, что в конечном итоге выбирается небольшое количество записей. Поэтому, цель оптимизации - уменьшить размер результирующего множества как можно раньше. В плане не должно быть полное сканирование больших таблиц (но маленьких может). На первых порах выполняется самый строгий критерий фильтрации. 

Оптимизация связана с индексами, т.к. нельзя быстро выбрать подмножество записей из таблицы без индекса. Соответственно, для ускорения коротких запросов необходимы индексы. Особенно актуально создание индекса при наличии сильно ограничительного условия (фильтрации). 

Очень внимательно нужно рассматривать запросы функциональным изменением столбцов и приведением к виду. Например, функция lower() у строки или приведение ::date у даты отключат индекс, потому что индекс привязан к конкретному значению, а перечисленные операции это значение изменяют. Можно сделать функциональный индекс (при создании на столбец применить необходимую функцию) или переписать запрос.

Во время выполнения короткого запроса может быть ситуация, когда используются несколько индексов вместе - в зависимости от количества и полноты проводимы фильтраций. 
___
[[Code]]:
```
1. Когда индекс перестает работать (функциональное преобразование, приведение)
SELECT*FROM flight WHERE sched_dep::date BETWEEN val1 AND val2 // ломает индекс
SELECT*FROM flight WHERE sched_dep BETWEEN val1 AND val2
2.
update_ts::date = CURRENT_DATE // ломает индекс
update_ts >= CURRENT_DATE AND update_ts < CURRENT_DATE + 1
3.
coalesce(col1, col2) // встройка psql тоже ломает индекс тк преобразует столбцы
4.
SELECT*FROM acc WHERE lower(last_name) LIKE 'johns%' // LIKE ломает индекс
SELECT*FROM acc WHERE lower(last_name) >= 'johns' AND lower(last_name) < 'johnt'
```
___
Language: [[SQL]]
Key-words:  [[Короткие запросы SQL]] [[Индексы SQL]]
Question query?: 