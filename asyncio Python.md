Асинхронное программирование в Python реализуется с помощью модуля asyncio. 

В Python асинхронность приходится на один поток и полностью блокирует другое исполнение, если оно не синронизированно с асинхронным циклом. 

Для определения сопрограммы используется конструкция:
`async def`

Сопрограмма называется ***корутин***. Корутин создается через:
`loop.create_task(func())`

Исполнение всех корутинов необходимо ожидать через `await`. 

Если не сделать `await`, то сопрограмма создатся, но не будет ожидаться. В таком случае создается ***future***. ***Future*** - это пустой объект, который в будущем должен принять значение и сигнализировать об этом. Если ***future*** не ожидается, то блок кода продолжит свое выполнение. 

Если объект future используется в дальнейшем коде явно или не явно, то это может послужить причиной ошибки. Тем не менее, такой подход может иметь место, если мы хотим асинхронно исполнить какую-то задачу, которая, например, сделает вывод в консоль или прочее, что не потребуется непосредственно в рамках работы приложения. 

`await` также является ***точкой возбуждения исключений***. 
Если сопрограмма не ожидается и нигде не сохранена (например, не сохранена в массиве), то исключение не будет обработано и при его возникновении выведется соответствующая ошибка. 

В это же время, если выполнено `await`, то оно является точкой возбуждения исключений. Если прописать над ним блок try/catch, то исключение будет обработано в соответствии с заданной логикой. 

___
Relations: [[Асинхронное программирование на Python]]
Tags: #theory 
References: [[Asyncio (книга)]] 
Query: 