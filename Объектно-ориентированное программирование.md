Объекто-ориентированное программирование заключается в том, чтобы модельно описывать окружающий мир в виде объектов в программном коде. 

Строго говоря, любой объект является каким-либо набором данным и присущим ему поведением. 

Каждый объект обладает какими-либо данными. Данные описывают состояние объекта. Данные всегда записаны под какими-либо атрибутами. Сам по себе класс не имеет значений атрибутов, он лишь определяет их необходимость. А вот экземпляр уже имеет значения атрибутов - и совсем не обязательно, чтобы атрибуты у каждого экземпляра класса были разными. Каждый атрибут при этом может быть задан по разному - обычно это делается с помощью примитивов, но могут использоваться и более сложные конструкции. Иными словами, каждый атрибут также является каким-либо экземпляром какого-либо класса и имеет свое значение и поведение.

Поведение класса задается через действия, которые можно выполнять с классом или которые класс может выполнить. Действия задаются через методы (функции). В отличии от обычных функций, методы класса имеют доступ к артибутам класса. 

Атрибуты и методы класса могут быть ***скрытыми***. Если методы и атрибуты не скрыты, они представляют собой ***публичный интерфейс*** - они определяют возможности взаимодействия нашего объекта с окружающим миром, то есть другими объектами. 

Необходимо заранее продумать публичный интерфейс класса. Потому что от него могут зависеть другие классы. Если на начальном этапе публичный интерфейс легко изменить так, чтобы код продолжал работать, то спустя время, когда экземпляры этого объекта будут использоваться другими объектами, любое координальное изменение может привести к полной неработоспособности программы. 

Естественно, лучше всего отделять публичный интерфейс от кодовой реализации. Мы можем изменить кодовую реализацию - оптимизировать вычисления или сделать рефакторинг и в это же время наш публичный интерфейс никак не будет затронут. Нужно держать в голове следующее: публичный интерфейс должен быть максимально прост к использованию, не важно как сложно будет это реализовать. 

***Скрытие информации*** - это процесс, когда не нужные детали скрываются. Существует также термин ***инкапсуляция***. Инкапсулирование и скрытие информации - это не одно и тоже. Инкапсуляция предполагает оборачивание информации (атрибутов) в объекте, но при этом атрибуты ***не обязательно должны быть скрыты***. 

***Взаимозаменяемость***. Объекто-ориентированное программирование помогает работать с единым интерфейсом различных объектов. Например, у нас есть контроллер птиц, который должен управлять птицами. В этом случае в качестве птицы может выступать любая птица, но все птицы относятся к классу птиц и имеют единый интерфейс, например, "передвигаться". Если контроллер опирается на поведение базового класса, то ему будет без разницы, как именно реализована функция передвижения, если она будет работать по определенному стандарту. 
![[Pasted image 20231027084542.png]]

Если рассматривать ООП с точки зрения компилируемых языков, то может возникнуть вопрос - как реализовать взаимозаменяемость, если объекты связываются на этапе компиляции. Компилятор не может сгенерировать вызов функции в традиционном смысле. В вызовах, скомпилированных обычным компилятором, применяется ***раннее связывание***. 

***Раннее связывание*** означает, что компилятор генерирует вызов функции с конкретным именем, а компоновщик преобразует этот вызов в абсолютный адрес выполняемой функции. В ООП программа не может определить адрес функции до выполнения программы, поэтому при отправке сообщения обобщенному объекту необходима другая схема компиляции. 

Для решения этой проблемы используется ***динамическое связывание*** (***позднее связывание***). При вызове метода какого-то объекта связывание не происходит до момента выполнения программы. Компилятор в таком случае лишь убеждается, что метод существует, проверяет типы аргументов и возвращаемого значения (в языках со слабой типизацией не происходит даже этого), но не знает куда именно будет передано управление. 

Кроме объектов мы можем использовать различные функции, которые будут работать с созданными объектами (независимо от того функции это или методы других объектов). Если мы имеем дело с наследованием, то у нас есть базовый класс и несколько производных. Так как объекты обладают одинаковыми свойствами, но немного отличаются друг от друга, они могут обрабатываться одной и той же функций, которая будет ожидать базовый класс. Интерпретаций объекта производного типа так, как если бы он относился к базовому типу, называется ***провышающим приведением типа***. 
![[Pasted image 20231105083242.png]]

___
Relations: [[Парадигмы программирования]] 
Tags: #theory 
References: [[Python Object Oriented Programming]] [[Философия C++ Эккель]] 
Query: 