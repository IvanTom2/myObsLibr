___
В python список это мутабельный массив данных, который способен в расширению и изменению на месте. 

Интересный момент насчет мутабельности. Если создавать вложенный список (список списков), то его поведение будет зависеть от того, как мы поступим при создании. Например, если мы создадим вложенный список в первом шагу, а затем добавим его несколько раз в контейнер, то при изменении любого элемента любого вложенного списка, будут изменены все элементы вложенных списков, которые стоят на той же позиции. В тоже время, если мы создаем объект в памяти (а не ссылку по дефолту), то такого не произойдет. Особенно это актуально в рамках итераторов (пример 1 в коде).

Сортировка массива, в т.ч. и списка, является дорогостоящей операцией. Так как список является изменяемым объектом, то при добавлении элемента (например append), чтобы получить отсортированную последовательно, необходимо будет заново отсортировать список. Это не очень эффективно и может быть гораздо проще вставлять элемент в позицию, которая не будет ломать последовательность - для таких операций используется модуль bisect. 

Несмотря на то, что список является удобным типом данных, он не всегда эффективен. Например, если хранить огромное количество чисел - лучше использовать array.array (он позволяет также сохранять и читать файлы более эффективно). Если часто добавляются и удаляются данные, то лучше может быть использовать deque (двусторонняя очередь). Если по массиву часто идет проверка вхождения значения, то лучше использовать множество (хотя оно не совсем массив и не отсортировано). 
___
[[Code]]:
```
1. При создании и послед. изменении элементов в списке:
board = [['_'] * 3 for i in range(3)] # изменится только один эл. вл. списка
board[1][2] = 'X' # [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]

weird_board = [['_'] * 3] * 3 # изменятся все эл. вл. списков 
weird_board[1][2] = 'O' # [['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']]
```
___
Language: [[Python]]
Key-words:  [[Структуры данных python]]
Question query?: 