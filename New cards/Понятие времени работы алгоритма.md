Время работы алгоритма измеряется не в реальном времени, а в количестве "шагов", необходимых для его выполнения. 

Нужно ввести важное допущение - каждая строка кода выполняется за фиксированное (и одинаковое между машинами) количество времени $c_i$ - это константа. 

После введения допущения, мы можем приступить к расчету количество повторений определенных строк. На примере [[Сортировка вставкой (insertion sort)]] - для каждого уровня итерации $[j, A.lenght]$ обозначим через $t_j$ количество проверок условия $while$. 

![[Pasted image 20231007162749.png]]
Комментарии, очевидно, стоимости не имеют. Если стоимость выполнения строки кода составляет $c_i$ и она выполняется $n$ раз, тогда ее вклад во время работы алгоритма будет составлять $c_in$. 

На основе составленой схемы повторов каждой строки кода мы можем определить полное время работы алгоритма сортировки вставкой $T(n)$:
$$T(n)=c_1n+c_2(n-1)+c_4(n-1)+c_5\sum\limits_{j=2}^{n}t_j+c_6\sum\limits_{j=2}^{n}(t_j-1)+c_7\sum\limits_{j=2}^{n}(t_j-1)+c_8(n-1)$$

На данном этапе мы можем выяснить, что время работы алгоритма зависит не только от размера входных данных, но и от их самих входных данных - их структуры, отсортированости и так далее. Например, для сортировки вставкой идеальный случай - когда входные данные сразу же отсортированны. 

Время работы самого благоприятного случая будет низкое. Потому что для каждого $j=2,3,...,n$ мы находим, что условие `while` будет проверяется один раз, так как $A[i] \le key$ когда $i$ равен $j-1$ - то есть в начале инициализации цикла `while`. Соответственно, общее время работы алгоритма составит:
$$T(n)=c_1n+c_2(n-1)+c_4(n-1)+c_5(n-1)+c_8(n-1)$$
$$T(n)=(c_1+c_2+c_3+c_4+c_5) \cdot n - (c_2+c_4+c_5+c_8)$$
Такое время работы можно записать как $an+b$, где $a,b$ - это константы, зависящие от величин $c_i$. Таким образом, ***время является линейной функцией*** от $n$. 

Наихудший случай реализуется тогда, когда массив данных будет отсортирован в убывающем порядке. В таком случае количество итераций в цикле `while` будет максимальным и придется сверять каждый элемент с каждым предыдущим:
$$\sum_{j=2}^{n} t_j=\sum_{j=2}^{n} j - 1=\frac{n(n+1)}{2}-1$$
$$\sum_{j=2}^{n} t_j-1=\sum_{j=2}^{n} j=\frac{n(n+1)}{2}$$
Общее время выполнения алгоритма в таком случае можно вычислить по следующей формуле. 
![[Pasted image 20231007193227.png]]
Соответственно, время работы в наихудшем случае можно записать как: 
$$T(n)=an^2+bn+c$$
Таким образом, мы имеем квадратичную функцию от $N$. 

Важно отметить, что ***обычно время работы для определенных входных данных фиксировано***. Тем не менее, существует ряд алгоритмов, которые имеют в своей основе элементы рандомизации и их поведение носит вероятностный характер, что также может влиять и на время выполнения. Соответственно, время работы для таких алгоритмов может менять для одни и тех же данных. 

Основное ***внимание обычно уделяется наихудшему времени работы алгоритма***. Так заведено, потому что наихудший вариант - это верхний предел для любых входных данных. Зная об этом, мы можем сказать, что точно не потребуется больше времени. 

В некоторых алгоритмах наихудший вариант может встречаться достаточно часто. Например, поиск в базе. Если искомого значения в базе нет, то всегда будет наступать наихудший вариант. 

Характер поведения усредненного времени работы алгоритма часто ничем не лучше поведения времени для наихудшего случая. Например, мы знаем, что в среднем для алгоритма сортировки вставкой половина элементов $A[1,...,j-1]$ меньше, чем $A[j]$, а другая половина - больше. Таким образом, в среднем придется проверить половину элементов подмассива $A[1, ..., j-1]$. Поэтому $t_j$ приблизительно будет равно $\frac{j}{2}$. В любом случае функция времени от количества элементов массива останется квадратичной функцией. 

До этого было введено упрощение по поводу времени работы каждой строки кода в виде константы $c_i$. Далее мы увидели, что учет всех констант дает излишнюю информацию, после чего свели все константы к одному коэффициенту.
Анализ алгоритмов обычно упрощяют еще больше, применяя так называемый ***порядок роста*** или ***скорость роста***. При анализе порядка роста, рассматривают только главный член формулы. Например, в формуле $an^2+bn+c$ будет учитываться только $n^2$. 

Таким образом, проводя анализ порядка роста алгоритма сортировки вставкой получаем: 
$$T(n)=\Theta(n^2)$$
Говорят, что алгоритм работает эффективнее, если его порядок роста ниже, чем порядок роста другого алгоритма. 
Тем не менее, на ***малых наборах данных алгоритм с более высоким порядком роста может работать быстрее***. Это связано с тем, что опускаются все коэффициенты и прочие переменные в уравнении зависимости скорости работы алгоритма от размера входных данных. 

___
Зачем это нужно: [[]] 
Примеры применения: [[]] 
Основные ошибки: [[]]
___
Relations: [[Алгоритмы и структуры данных]] [[Понятие размера входных данных]] 
Tags: #theory 
References: [[Алгоритмы построение и анализ Кормен]] 
Query: 