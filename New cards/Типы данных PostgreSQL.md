***Числовые типы данных***. 

Целочисленные типы данных: `smallint`, `integer`, `bigint`. Для данных типов также можно задать количество байтов, выделяемых для их хранения: `int2`, `int4`, `int8`. При выборе целочисленного типа принимают во внимание диапазон допустимых значений и затраты памяти на хранение. Обычно `integer` достаточен. 

Числа фиксированной точности: `numeric`, `decimal`. Оба типа являются идентичными по своим возможностям. Для этих типов можно задать масштаб и точность: у числа $12.3456$ точность 6 чисел, а масштаб 4, тогда можно задать `numeric(6, 4)`. 
Главное достоинство `numeric` в том, что он обеспечивает точность вычислений. Числа этого типа могут хранить очень большие значения: 131072 цифры до точки и 16383 числа после точки. ***Чем выше точность, тем ниже скорость вычислений***. Обычно данный тип используется для хранения денежных сумм и прочих случаях, когда требуются точные вычисления. 

Типы данных с плавающей точкой: `real`, `double precision`. Тип `real` может представлять число от `1E-37` до `1E+37` с точность ***не меньше 6 десятичных цифр***, в то время как `double precision` от `1E-307` до `1E+308` с точностью ***не меньше 15 десятичных цифр***. 
Если записать слишком большое или слишком маленькое значение под данными типом, то будет генерироваться ошибка. Если точность выше допустимой, то будет производиться округление. При вводе слишком маленьких числе едва отличимых от нуля, будет генерироваться ошибка потери значимости. Сравнение чисел с плавающей точкой может иметь неожиданный результат:
`SELECT 0.1::real * 10 = 1.0::real; -> FALSE`
Типы с плавающей точкой поддерживают значения `Infinity`, `-Infinity`, `NaN`. 

PostgreSQL поддерживает `float`. `float(n)` где $n$ от 1 до 24 - это `real`, где от 25 до 53 - равносильно `double precision`. Если при объявлении не используется параметр, то это `double precision`. 

Последний числовой тип - `serial`. Это не настоящий тип, а удобная замена ряда операций. Этот тип удобен для генерации суррогатных первичных ключей. Кроме `serial` есть `bigserial` и `smallserial`. По сути, они ничем не отличаются, кроме хранимых значений. 

***Строковые типы данных***. 
Стандартные типы - `character varying(n)` и `character`, где $n$ - максимальное количество символов (не байтов). Тип `character` всегда дополняет строку пробелами, если количество символов меньше $n$. Оба типа имеют псевдонимы `varchar` и `char` соответственно. 
Для больших текстов есть дополнительный тип `text`, который позволяет вводить сколь угодно большие тексты (в пределах установленных ограничений при компиляции исходника СУБД). 

Чтобы ввести текстовый литерал, используются кавычки `''`. Чтобы ввести кавычку в кавычках или косую черту, нужно прописать их дважды, например: `'text1''text2'`. Либо использовать `$$text$$` заместо кавычек. 

***Типы дата и время***. 
Самый основной тип `date`, который представлен как `yyyy-mm-dd`. Также доступны и другие форматы для ввода, например, `Sep 12, 2016`. 

Для хранения времени суток используют `time` и `time with time zone` и второй тип хранит дополнительно к времени суток еще и часовой пояс (документация PostgreSQL не рекомендует использовать последний, так как в часовых поясах есть переход на летнее время, а в данном типе дата не присутствует). 

Объединение даты и времени называются ***временной отметкой***. Для временных отметок существуют типы `timestamp` и `timestamp with time zone` или псевдоним `timestamptz`. 

Существует также тип для хранения ***временных диапазонов*** `interval`: `quantity unit [quantitiy unit ...] direction`. Например `SELECT '1 year 2 months ago'::interval;`. Здесь `quantity` обозначает количество и `unit` единиц измерения. В примере `quantity=1` и `unit=year`. В качестве `unit` выступают `microsecond, millisecond, second, minute, hour, day, week, month, year, decade, century, millennium`. 

В PostgreSQL существует большое количество функций для работы со временем. Например, функция `date_trunc`, которая обрезает время до необходимо отметки (все что после, например, часа - удаляется). `SELECT (date_trunc('hour', current_timestamp));`. 
`extract` используется для извлечения значения какой-то метки (например, месяца) `SELECT extract('mon' FROM timestamp '1999-11-27 12:34:56.123459');`. 

***Логические типы***. 
Логические типы это `bool`, которые принимают `TRUE`, `FALSE`, `NULL`. 
`TRUE` можно задать: `TRUE`, `'t'`, `'true'`, `'y'`, `'yes'`, `'on'`, `'1'`. 
`FALSE` можно задать: `FALSE`, `'f'`, `'false'`, `'n'`, `'no'`, `'off'`, `'0'`. 

Фича при работе с атрибутами логического типа в том, что необязательно указывать при формировании представления через `WHERE bool_attr=True`, достаточно `WHERE bool_attr`. 

***Массивы***. 
PostgreSQL способен хранить в качестве значений не только скаляры, но и массивы. Причем в качестве значений массивов могут выступать любые данные, в том числе кастомные типы. ***Индексация массивов начинается с единицы***. 

***Тип JSON***. 
Существует два типа: `json` и `jsonb`. Различие в быстродействии. `json` быстрее вводится в таблицу, не разбирается на составные части и далее при вызове возвращается как текст и ***каждый раз*** разбирается. `jsonb` при вводе в таблицу происходит однократный разбор (который занимает время на этапе ввода) и в дальнейших операциях участвует в разобраном виде. 

Второе отличие этих типов в том, что `json` сохраняет порядок следования ключей, а `jsonb` нет. Обычно рекомендуется использовать `jsonb`, если нет каких-то веских аргументов к обратному. 


___
```
CREATE TABLE {tabname} ({colname} SERIAL) \\ одинаково с нижним
==
CREATE SEQUENCE {tabname_seq};
CREATE TABLE {tabname} (
	{colname} INTEGER NOT NULL, DEFAULT nextval('{tabname_seq}')
	);
ALTER SEQUENCE {tabname_seq} OWNED BY {tabname}.{colname};

\\ создание массива в качестве атрибута
CREATE TABLE pilots (
	pilot_name text,
	schedule integer[]
);

\\ введение данных в качестве массива
INSERT INTO pilots
VALUES (
	('Ivan', '{ 1, 3, 5, 6, 7 }'::integer[] ),
	( 'Petr', '{ 1, 2, 5, 7}'::integer[] ),
	( 'Pavel', '{ 2, 5}'::integer[] ),
	( 'Boris', '{ 3, 5, 6}'::integer[])
);

\\ конкатенация массива
UPDATE pilots
	SET schedule = schedule || 7
	WHERE pilot_name = 'Boris';

\\ append массива
UPDATE pilots
	SET schedule = array_append( schedule, 6 )
	WHERE pilot_name = 'Pavel';

\\ prepend массива
UPDATE pilots
	SET schedule = array_prepend( 1, schedule )
	WHERE pilot_name = 'Pavel';

\\ убираем значение из массива
UPDATE pilots
	SET schedule = array_remove( schedule, 5 )
	WHERE pilot_name = 'Ivan';

\\ изменение значений по индексу массива
UPDATE pilots
	SET 
		schedule[ 1 ] = 2, 
		schedule[ 2 ] = 3
	WHERE pilot_name = 'Petr';

\\ изменеие значений по срезу массива
UPDATE pilots
	SET schedule[ 1:2 ] = ARRAY[ 2, 3 ]
	WHERE pilot_name = 'Petr';

\\ поиск индекса по значению (ищем значение 3)
SELECT * FROM pilots
	WHERE array_position( schedule, 3 ) IS NOT NULL;

\\ проверка нахождения всех элементов массива справа в левом
SELECT * FROM pilots
WHERE schedule @> '{ 1, 7 }'::integer[];

\\ пересечение массивов
SELECT * FROM pilots
	WHERE schedule && ARRAY[ 2, 5 ];
	
SELECT * FROM pilots
	WHERE NOT ( schedule && ARRAY[ 2, 5 ] );

\\ развернуть массив в качестве столбца (транспонировать)
SELECT unnest( schedule ) AS days_of_week
	FROM pilots
	WHERE pilot_name = 'Ivan';

\\ создание таблицы с атрибутом JSON
CREATE TABLE pilot_hobbies
(
	pilot_name text,
	hobbies jsonb
);

INSERT INTO pilot_hobbies
	VALUES 
	( 'Ivan', '{ "sports": [ "футбол", "плавание" ],
		"home_lib": true, "trips": 3}'::jsonb),
	( 'Petr', '{ "sports": [ "теннис", "плавание" ],
		"home_lib": true, "trips": 2}'::jsonb),
	( 'Pavel', '{ "sports": [ "плавание" ],
		"home_lib": false, "trips": 4}'::jsonb),
	( 'Boris', '{ "sports": [ "футбол", "плавание", "теннис" ],
		"home_lib": true, "trips": 0}'::jsonb);



```
___
Зачем это нужно: [[]] 
Примеры применения: [[]] 
Основные ошибки: [[]]
___
Relations: [[PostgreSQL]] 
Tags: #code
References: [[Изучаем PostgreSQL]] 
Query: 