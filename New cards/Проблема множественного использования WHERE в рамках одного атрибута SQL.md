На примере тестовой базы данных `PC, Laptop & Printer`. Задача: необходимо выбрать только тех производителей, которые производят `PC` и не производят `Laptop`. 

В атрибуте `type` записан тип производимого продукта. Через него можно было бы выбрать всех нужных производителей. 
Рассмотрим неверное решение. Казалось бы, оно логичное - мы должны извлечь производителей, которые выпускаю `PC` и не выпускают `Laptop`. Тем не менее, ***результат операции определен последовательно***. Сначала выполняется первый предикат и выводятся только те производители, которые выпускаю `PC`. Зачем отфильтровываются те, которые производят `Laptop` - но таких по определению нет. 

Для решения задачи необходимо извлечь два множества по условию и затем пересечь их правильных образом. Стоит заметить, что `EXCEPT` автоматически удаляет дубликаты, если только не добавить `EXCEPT ALL`. 

___
```
// wrong solution
SELECT DICTINCT maker FROM
	product
WHERE
	type = 'PC' and type != 'Laptop'

// right solution
SELECT
    maker
FROM
    product
WHERE
    type = 'PC'
EXCEPT
SELECT
    maker
FROM
    product
WHERE
    type = 'Laptop';


```
___
Зачем это нужно: [[]] 
Примеры применения: [[]] 
Основные ошибки: [[]]
___
Relations: [[Предикаты PostgreSQL]] 
Tags: #code
References: 
Query: 