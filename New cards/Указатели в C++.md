Указатели подобно ссылкам используются для косвенного доступа к объектам. В отличии от ссылок, указатель это настоящий объект. Указатели могут быть присвоены и скопированы. Указатель за время своего существования может указывать на различные объекты. В отличие от ссылки, указатель можно не инициализировать во время определения. Как и у других объектов, значение неинициализированного указателя, определенного в области видимости блока, неопределено. 

Указатели определяются с помощью оператора в форме `*<var>`, где `<var>` это имя указателя. 

Указатель содержит адрес другого объекта. Для получения адреса используется оператор обращения к адресу `&<var>` (address-of operator). Для обращения к адресу объекта используется оператор 
`*<pointer>` (dereference operator). 

За двумя исключениями, тип указателя и переменной, на которую он указывает, должны совпадать:
1. [[Указатель на константу C++]] 
2. 

Стоит заметить, что как и в случае с ссылками, указатель работает со значением объекта, на который указывает. Соответственно, если указателю присвоить новое значение, то изменится ничто иное, как объект, на который он указывает. 

Нулевой указатель можно определять по разному. Нулевой указатель не указывает ни на какой объект. Так как указатель сам по себе является детерминированным объектом, то его можно использовать в логических конструкциях: нулевой указатель будет интерпретироваться как `false`, в противном случае как `true`. 

Два указателя можно сравнить, результатом операции сравнения будет значение типа `bool`. Два указателя равны, если они оба нулевые, либо если они оба содержат одинаковый адрес, либо если они оба указывают на тот же объект или область непосредственно за концом того же объекта. ***Нужно понимать, что указатель на объект и указатель на область за концом другого объекта вполне могут содержать одинаковый адрес и они равны***. 

Тип `void*` является указателем специального типа, способный содержать адрес любого типа. Подобно другому указателю, указатель `void*` содержит адрес, но тип объекта по этому адресу неизвестен. Операции с таким типом ограничены: сравнение с другим указателем, передать или вернуть из функции, присвоить другому указателю тип `void*`. ***Данный тип не используют для работы с объектами***. 

Так как указатели являются объектом в памяти, на них можно делать указатели. Каждый последующий указатель на указатель требует на 1 dereference operator `*` больше. Соответственно, при попытке вывести значение по указателю, нужно указать столько же `*`, сколько и при определении. Такое поведение связано с тем, что указатель указывает на указатель, в то время как тот указывает на адрес и его значением будет тоже адрес ячейки памяти. 

___
```
int *p1, *p2 // указатели типа int
double dp, *dp2 // переменная и указатель типа double

int ival = 42
int *p = &ival // инициализация указателя
std::cout << *p << std::endl; // cout 42
*p = 0
std::cout << *p << std::endl; // cout 0

// определение нулевого указателя
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL; // нужно избегать этого, используя nullptr

// указатели на указатели
int var = 999;
int *p1 = &var;
int **p2 = &p1;
int ***p3 = &p2;

```
___
Зачем это нужно: [[]] 
Примеры применения: [[Совет по инициализации указателей C++]] 
Основные ошибки: [[]]
___
Relations: [[C++]] [[Составные типы C++]] 
Tags: #code
References: [[Язык программирования C++ базовый курс]] 
Query: 