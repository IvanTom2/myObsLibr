Преобразование одних типов данных в другие может приводить к неожиданными последствиям (не смотря на то, что они, на самом деле, вполне определены и ожидаемы). 

`bool`. Если на вход данного типа будет подаваться значение, отличное от `true` или `false`, то произойдет следующее. Если на вход будет подан 0, то булево значение будет `false`. Если на вход будет подано значение, отличное от 0, то булево значение будет `true`. Это правило схоже с Python (т.к. Python написан на C). Но не схоже, например, с [[Булева алгебра и логические операторы Ruby]]. 
Важно отметить, что при создании строки через `const char str[]` ***даже пустая строка будет интерпретрироваться как*** `true`. 

Соответственно, при присваивании значения типа `bool` любому арифметическому типу данных, оно получит значение 1 в случае `true` и 0 в случае `false`. 

Когда любое значение с плавающей точкой присваивается целочисленному типу данных, то оно автоматически обрезается.

Когда любое целочисленное значение присваивается типу с плавающей точкой, то его дробной частью становится нуль. Если у целого числа больше битов, чем может вместить объект с плавающей точкой, то точность может быть потеряна. 

Если объекту беззнакового типа присваивается отрицательное число, то он автоматически станет положительным обратным числом. Например, если `unsigned int` присвоить значение -1, то значение этой перенной будет 4294967295 (максимальное значение). Отрицательные числа пойдут в обратную сторону от максимального при убывании. 

***Преобразование типо иногда происходит неявно!!!***
Самый очевидный пример в сложении `unsigned int` и `int`. При сложении двух разных типов данных, один преобразовывается в другой. Так, `int` с отрицательным значением -1 будет преобразован в `unsigned int` со значением 4294967295.

Второй пример: вычитание `unsigned int` таким образом, что результатом получается отрицательное число. В таком случае отрицательное число по той же схеме будет преобразовано в `unsigned int` - около 4294967295. 

Третий пример: использование `unsigned int` в циклах. Например, мы написали:
```
for (unsigned int i = 10; i >= 0; --i)
std::cout << i << std::endl;
```
В таком случае ***цикл никогда не закончится, потому что*** `unsigned int` ***не может быть больше нуля***.  

___
```
#include <iostream>

template <typename T>

void printer(T to_type, const char prnt[])
{
    std::cout << prnt << " -> " << to_type << std::endl;
}

int main()
{
    bool b = 42;
    printer(b, "Bool from 42 is");

    const char A[] = "ABC";
    bool check_A = A;
    printer(check_A, "Check what'll happen if pass string 'ABC' to bool");

    const char B[] = "";
    bool check_B = B;
    printer(check_B, "Check what'll happen if pass empty string to bool");

    unsigned unsg = 10;
    unsigned unsg2 = 11;
    int sgn = -42;
    printer(unsg + unsg, "Add unsigned 10 to unsigned 10");
    printer(unsg + sgn, "Add signed -42 to unsigned 10");
    printer(unsg - unsg2, "Subtract unsigned 11 from unsigned 10");

    int i = b;
    printer(i, "Make int from bool");

    i = 3.14;
    printer(i, "Try to fit float 3.14 in int");

    double pi = i;
    printer(pi, "Try to convert int(3.14) to double");

    unsigned int uint = -1;
    printer(uint, "Try to fit -1 in unsigned char");

    // don't work because of overflow error
    // unsigned int uint2 = 4294967296;
    // printer(uint2, "Try to overflow 4294967296 in unsigned int");

    return 0;
}
```
___
Зачем это нужно: [[]] 
Примеры применения: [[]] 
Основные ошибки: [[]]
___
Relations: [[Типы данных C++]] 
Tags: #code
References: 
Query: 