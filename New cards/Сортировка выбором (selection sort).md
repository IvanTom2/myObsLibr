Данный алгоритм выполнен мной. 

1. Определяется наименьший элемент массива $A$. 
2. Найденный элемент встает на позицию $A[1]$. 
3. Элемент на позиции $A[1]$ заменяет позицию найденного элемента.
4. Так продолжается до тех пор, пока не настанет $n-1$ итерация. 

Код сортировки выбором приведен на языке Python. Здесь показана оптимизация кода, которая приводит к значительному сокращению времени выполнения:
1. Количество итераций сокращено с $n$ до $n-1$, так как последний оставшийся элемент массива, очевидно, самый большой. 
2. Максимально снижено количество использования промежуточных переменных. Так было устранено хранение минимального значения, вызов текущего элемента. 

> Суть алгоритма в том, что мы двигаемся от начала массива к его концу. С каждой итерацией мы уменьшаем необходимый для сортировки массив на 1 индекс. С каждой итерацией мы оставляем после себя отсортированный подмассив. На каждой итерации мы ищем минимальное значение в неотсортированном подмассиве (***перебираем и сравниваем все***). 

***Порядок роста***. 
В случае сортировки выбором, время всегда будет одинаковое независимо от входных данных. Эта особенность возникает потому, что нам необходимо перебрать весь неотсортированный массив для поиска минимального значения (даже если его там и нет). Так как у нас есть вложенный цикл, перебор значений занимает $N^2$ времени. 
$$T(N)=\Theta(N^2)$$

___
```
# unoptimized code
def unoptimized_selection_sort(array: list) -> list:
    for sort_index in range(len(array)):
        swap_origin = array[sort_index]
        swap_index = sort_index

        _min = array[sort_index]

        # can use enumerate
        for element_index in range(sort_index + 1, len(array)):
            element = array[element_index]
            if _min > element:
                _min = element
                swap_index = element_index

        array[sort_index] = _min
        array[swap_index] = swap_origin

    return array

# optimized
def my_selection_sort(array: list) -> list:
    array_size = len(array)

    for step_index in range(array_size - 1):
        index_min = step_index

        # can use enumerate
        for element_index in range(step_index + 1, array_size):
            if array[index_min] > array[element_index]:
                index_min = element_index

        (array[step_index], array[index_min]) = (array[index_min], array[step_index])

    return array
```

> Стоит заметить, что в приведенном выше коде используется не $n$ итерацией, а $n-1$ итераций верхнего цикла.

> Нужно отметить тот момент, что на Python есть возможность сделать перезапись двух элементов на места друг друга (поменять местами) так, чтобы не нужно было создавать дополнительную переменную. 

___
Зачем это нужно: [[]] 
Примеры применения: [[]] 
Основные ошибки: [[]]
___
Relations: [[Алгоритмы сортировки]] 
Tags: #theory 
References: [[Алгоритмы построение и анализ Кормен]] 
Query: 