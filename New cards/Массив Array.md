Зачем нужны массивы и прочие структуры данных? Предположим, что у нас есть ряд переменных (например, значения атрибутов людей) - мы можем хранить каждую переменную отдельно, но лишь до того момента, как их количество не перерастет за 10 - в таком случае нам необходимо инициализировать 10 переменных, что является трудоемким процессом. Тем не менее, более трудоемким процессом будет дальнейшая работа с этим множество переменных.

Массив позволяет хранить определенное количество значений, инициализируя лишь одну переменную. В дальнейшем мы будем иметь одинаковый доступ ко всем значениям и сможем применять к ним любые операции. 

Массив является линейной структурой данных, которая позволяет хранить значения ***одинаковых типов*** в смежных ячейках памяти (рядом друг с другом). 

При создании массива, выделяется ***блок оперативной памяти***. Опять же, под блоком имеется в виду последовательность ячеек памяти, которые находятся рядом друг с другом. Массив содержит информацию о каждом адресе из этого блока. Кроме того, каждая ячейка проиндексирована - индекс представляет из себя пользовательский интерфейс доступа к элементам. Получается, что даже не зная адреса, мы можем обратиться к любому элементу массива по его индексу и получить значение из памяти, так как значения, ячейки памяти и индекс связаны. 
![[Pasted image 20231118083907.png]]

Каждый массив имеет нижнюю границу и верхнюю границу. Их можно рассматривать с разных точек зрения, но в конечном итоге нижняя граница представляет из себя первую инициализированную ячейку памяти, а верхняя граница - последнюю. Соответственно, нижняя граница всегда имеет индекс 0 (или 1 в некоторых ЯП). В то время как верхняя граница может быть любым числом, отражающим максимальный индекс массива. 

Массив по дефолту имеет статичный тип памяти. Иными словами, когда мы определяем массив, то определяем его размер (количество допустных ячеек памяти) и не можем его изменять. В таком случае возникают следующие проблемы:
1. Недостаток ячеек памяти для хранения большего числа элементов. Невозможно внести новый элемент в массив. 
2. Переизбыток памяти - когда массив содержит меньше элементов, чем может себе позволить. В таком случае мы имеем ***неэффективное использование памяти***. 

Выделение блока памяти имеет важное значение для массива. Дело в том, что индекс массива и блок памяти ***явно не связаны***. Когда мы обращаемся к определенному индексу элемента, происходит ***вычисление адреса в памяти***:
$$addr_{element}=addr_{low\ bound}+(size_{element} \times index)$$
Таким образом вычисляется адрес. Как можно видеть, что в вычислениях присутствует нижняя граница массива - она указывает на то, с какой ячейки памяти начинается блок памяти, выделенный под массив. Вычислив адрес, компилятор извлекает значение, хранящееся в ячейке памяти. 

Стоимость операций с массивом:
1. Доступ по индексу `O(1)`. По индексу вычисляется номер ячейки памяти и идет прямое обращение к ней. 
2. Присваивание по индексу `O(1)`. По индексу вычисляется номер ячейки памяти и присваивается новое значение. 
3. Добавление в конец массива `O(1)`. На уровне массива существует индикатор заполненности, который позволяет вычислить последний индекс с пустым значением. По этому индексу вычисляется ячейка памяти, куда записывается значение. Стоимость `O(1)` реальна лишь в статическом массиве, в динамическом массиве при полном заполнении массива происходит расширение, которое занимает `O(n)`. 
4. Удаление с извлечением из конца списка `O(1)`. 
5. Удаление с извлечением по индексу `O(n-i)`. Стоимость связана с тем, что происходит операция левого сдвига. 
6. Добавление по индексу `O(n-i)`. Отличие по скорости по сравнению с добавление в конец массива обусловлена необходимостью правого сдвига. 
7. Проверка присутствия значения в списке. Если массив не отсортирован, то brute-force `O(n)`. Если массив отсортирован, то binary-search `O(log(n))`. 
8. Объединение двух списков `O(n1+n2)`. Создается новый блок памяти, в него перезаписываются все значения. 
9. Сортировка. Зависит от алгоритма. Лучшая скорость `O(n log2(n)`. 

Массивы делятся на несколько типов:
1. [[Одномерный массив One Dimensional Array]] 
2. [[Многомерный массив Multidimensional Array]] 
3. [[Динамический массив Dynamic Array]] 

Преимущества массива:
1. Возможность доступа к случайному элементу. 
2. Преимущество в локализации кэша. Извлечение из памяти одного элемента массива влечет за собой загрузку в кэш всего массива, что дает огромное преимущество в скорости при итеративных операциях (например, в отличие от Linked List). 
3. Используется для реализации других структур данных.

Недостатки массива:
1. Большинство массивов не имеют возможности изменять размер выделенного для них блока памяти. 
2. Выделение меньшего размера блока памяти, чем нужно, может привести к потерям данных. 
3. Не может хранить различные типы данных вместе. 
4. Так как данные хранятся в блоке памяти (последовательном ряде ячеек памяти), реализация операций удаления и вставки является тяжелой с точки зрения разработки. 

___
```

```
___
Зачем это нужно: [[]] 
Примеры применения: [[]] 
Основные ошибки: [[]]
___
Relations: [[Структуры данных]] 
Tags: #code
References: 
Query: 