FIFO (first in first out) очередь - это очередь, в которой обработка задач начинается с конца (то есть с той задачи, которая первая поступила в очередь). Иными словами, для обработки будет извлечен первый поступивший в очередь. 

В приложенном ниже коде используется асинхронная FIFO очередь `Queue`. Создано несколько задач. Клиентские задачи отложены в созданную очередь. В это же время созданы задачи-исполнители. В задачах исполнителях задан цикл, который оканчивается только в том случае, если очередь опустеет. Все задачи собраны и ожидаются в `asycnio.gather()`. Стоит заметить, что задачи из очереди ожидаются с помощью метода `queue.join()`, который передан в `asyncio.gather()`. С помощью метода `queue.join()` сопрограмма `main()` блокируется до того момента, пока не будут выполнены все задачи из очереди. Также нужно заметить, что все исключения передаются в `main()`. 

Задачи помещаются в очередь с помощью методов `queue.put_nowait` и забираются с тем же суффиксом `queue.get_nowait`. Также существуют методы `queue.get` и `queue.put`, которые являются ***блокирующими***. 

Данные методы нужны для следующих ситуаций. Сейчас очередь клиентов создается перед исполнением задач - в нее помещается сразу же 10 задач. В реальной жизни задачи будут поступать постепенно, в точности как в магазине покупатели будут приходить с различными промежутками времени на протяжении всего дня. В таком случае наша реализация не будет работать, так как после завершения задач в очереди программа также завершится. 

В описанном выше случае, нам необходимо было бы реализовать цикл `while True`, который бы продолжал работать вечно. Но дело в том, что метод `queue.get_nowait` возбуждает исключение, если в очереди не остается задач. Если для этого случая написать обработчик исключений, то он будет поглащать большое количество процессорного времени. В то же время метод `queue.get` блокирует выполнение, ожидая новую задачи в очереди. 

Также существует вторая проблема. Что, если в очередь за короткий промежуток времени поместить 10000 задач? В таком случае очередь будет очень плотной и задачи вместе с поступившими данными будут занимать очень много оперативной памяти, так как по умолчанию очереди не ограничены и могут расти до бесконечности. Можно добавить ограничение в очередь, создав ее с максимальным размером `Queue(maxsize=N)`. Проблема в том, что при добавлении задач в такую очередь с помощью `queue.put_nowait` будет возникать исключение, когда очередь станет переполнена. Для этого есть метод `queue.put`. 

Асинхронные очереди можно использовать и в веб-приложениях. Но стоит учесть, что очередь хранит все задачи в оперативной памяти и в случае сбоя программы или сервера, все задачи будут потеряны. Например, так можно потерять заказы в интернет-магазине. 
Для того, чтобы избежать критических потерь, можно промежуточно использовать базу данных, в которой буду храниться все заказы. Либо можно использовать выносить эту задачу за рамки Python, используя, например, асинхронную очередь Celery или брокер сообщений RabbitMQ. 

___
```
import asyncio
from asyncio import Queue
from random import randrange
from typing import List


class Product:
    def __init__(
        self,
        name: str,
        checkout_time: float,
    ) -> None:
        self.name = name
        self.checkout_time = checkout_time


class Customer:
    def __init__(
        self,
        customer_id: int,
        products: List[Product],
    ) -> None:
        self.customer_id = customer_id
        self.products = products


async def checkout_customer(
    queue: Queue,
    cashier_number: int,
) -> None:
    while not queue.empty():
        customer: Customer = queue.get_nowait()
        print(f"Кассир {cashier_number} обсуживает покупателя {customer.customer_id}")

        for product in customer.products:
            print(
                f"Кассир {cashier_number} обрабатывает "
                f"{customer.customer_id} товар: {product.name}"
            )
            await asyncio.sleep(product.checkout_time)

        print(f"Кассир {cashier_number} обсужил {customer.customer_id}")
        queue.task_done()


async def main():
    customer_queue = Queue()
    all_products = [
        Product("Пиво", 2),
        Product("Бананы", 0.5),
        Product("Колбаса", 0.2),
        Product("Подгузники", 0.2),
    ]

    for i in range(10):
        products = [
            all_products[randrange(len(all_products))] for _ in range(randrange(10))
        ]
        customer_queue.put_nowait(Customer(i, products))

    cashiers = [
        asyncio.create_task(checkout_customer(customer_queue, i)) for i in range(3)
    ]

    await asyncio.gather(customer_queue.join(), *cashiers)


if __name__ == "__main__":
    asyncio.run(main())

```
___
Зачем это нужно: [[]] 
Примеры применения: [[]] 
Основные ошибки: [[]]
___
Relations: [[asyncio Python]] 
Tags: #code
References: [[Asyncio (книга)]] 
Query: 